# Тестовое задание

Мессенджер с вебсокетами, где пользователи могут писать сообщения друг другу или же в группах, которые могут создавать.

Стек технологий:

- ✅ Python, asyncio
- ✅ FastAPI, REST, WebSockets
- ✅ PostgreSQL, Async SQLAlchemy
- ✅ JWT
- ✅ docker, docker-compose
- ✅ pre-commit, isort, black, ruff
- ✅ pytest
- ✅ poetry
- ✅ Дедубликация сообщений при запросе создания сообщения пользователем на несколько инстансов сервиса одновременно (повышает отказоустойчивость в микросервисной архитектуре)


Поднять можно с помощью `docker-compose up --build`.

Команду для создания тестовых данных создавать не стал. Вместо этого, при запуске сразу создадутся таблицы БД с тестовыми данными.

Пользователи:

- `test1@test.com`
- `test2@test.com`
- `test3@test.com`

Для всех один и тот же пароль `test`

На странице `localhost:8000/docs` можно авторизоваться (кнопка Authorize справа сверху), используя email в качестве поля `username` и пароль. Эта плашка сама ходит на ручку `/login`. Используется JWT. Для поддержки одновременного логина с нескольких устройств, предполагаю, что пользователь в поле `client_id` указывал бы уникальный для своего девайса идентификатор.

`POST /messages/user/{user_id}` - написать другому пользователю. `operation_id` - поле, в которое пользователь генерирует случайное число `int16`. Отправляя сразу несколько запросов на разные инстансы сервиса, создастся только одно сообщение. Спустя 5 минут снова можно будет использовать этот `operation_id`. Также создастся чат, id которого будет в ответе. Можно будет потом подключиться по вебсокету.

`POST /group` - создать группу с перечисленными участниками. Автор всегда становится участником этой группы. Вернёт группу и chat_id, по которому можно будет подключиться по вебсокету.

`POST /messages/group/{group_id}` - написать в группу. Тут используется та же схема с убиранием дублирования по `operation_id`.

`POST /messages/read/{message_id}` - отметить сообщение как прочитанное

`GET /history/{chat_id}` - получить историю сообщений. Я использовал не OFFSET, а фильтрацию по id сообщения. OFFSET бы читал лишние страницы БД.

Вебсокет доступен по `/ws/{chat_id}`. Если подключились к чату, привязанному к группе, то будут по нему приходить сообщения от других пользователей. Если мы напишем и все остальные пользователи прочтут, мы получим отбивку о том, что наше сообщение прочитали. Аналогично работает и персональный чат.
